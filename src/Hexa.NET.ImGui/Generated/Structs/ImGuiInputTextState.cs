// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.ImGui
{
	/// <summary>
	/// Internal state of the currently focusededited text input box<br/>
	/// For a given item ID, access with ImGui::GetInputTextState()<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiInputTextState
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiContext* Ctx;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe STBTexteditState* Stb;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiInputTextFlags Flags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint ID;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int TextLen;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe byte* TextSrc;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVector<byte> TextA;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVector<byte> TextToRevertTo;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVector<byte> CallbackTextBackup;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int BufCapacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 Scroll;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float CursorAnim;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte CursorFollow;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte SelectedAllMouseLock;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte Edited;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte WantReloadUserBuf;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int ReloadSelectionStart;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int ReloadSelectionEnd;


		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiInputTextState(ImGuiContextPtr ctx = default, STBTexteditState* stb = default, ImGuiInputTextFlags flags = default, uint id = default, int textLen = default, byte* textSrc = default, ImVector<byte> textA = default, ImVector<byte> textToRevertTo = default, ImVector<byte> callbackTextBackup = default, int bufCapacity = default, Vector2 scroll = default, float cursorAnim = default, bool cursorFollow = default, bool selectedAllMouseLock = default, bool edited = default, bool wantReloadUserBuf = default, int reloadSelectionStart = default, int reloadSelectionEnd = default)
		{
			Ctx = ctx;
			Stb = stb;
			Flags = flags;
			ID = id;
			TextLen = textLen;
			TextSrc = textSrc;
			TextA = textA;
			TextToRevertTo = textToRevertTo;
			CallbackTextBackup = callbackTextBackup;
			BufCapacity = bufCapacity;
			Scroll = scroll;
			CursorAnim = cursorAnim;
			CursorFollow = cursorFollow ? (byte)1 : (byte)0;
			SelectedAllMouseLock = selectedAllMouseLock ? (byte)1 : (byte)0;
			Edited = edited ? (byte)1 : (byte)0;
			WantReloadUserBuf = wantReloadUserBuf ? (byte)1 : (byte)0;
			ReloadSelectionStart = reloadSelectionStart;
			ReloadSelectionEnd = reloadSelectionEnd;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	#if NET5_0_OR_GREATER
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	#endif
	public unsafe struct ImGuiInputTextStatePtr : IEquatable<ImGuiInputTextStatePtr>
	{
		public ImGuiInputTextStatePtr(ImGuiInputTextState* handle) { Handle = handle; }

		public ImGuiInputTextState* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiInputTextStatePtr Null => new ImGuiInputTextStatePtr(null);

		public ImGuiInputTextState this[int index] { get => Handle[index]; set => Handle[index] = value; }

		public static implicit operator ImGuiInputTextStatePtr(ImGuiInputTextState* handle) => new ImGuiInputTextStatePtr(handle);

		public static implicit operator ImGuiInputTextState*(ImGuiInputTextStatePtr handle) => handle.Handle;

		public static bool operator ==(ImGuiInputTextStatePtr left, ImGuiInputTextStatePtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiInputTextStatePtr left, ImGuiInputTextStatePtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiInputTextStatePtr left, ImGuiInputTextState* right) => left.Handle == right;

		public static bool operator !=(ImGuiInputTextStatePtr left, ImGuiInputTextState* right) => left.Handle != right;

		public bool Equals(ImGuiInputTextStatePtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiInputTextStatePtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		#if NET5_0_OR_GREATER
		private string DebuggerDisplay => string.Format("ImGuiInputTextStatePtr [0x{0}]", ((nuint)Handle).ToString("X"));
		#endif
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref ImGuiContextPtr Ctx => ref Unsafe.AsRef<ImGuiContextPtr>(&Handle->Ctx);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref STBTexteditStatePtr Stb => ref Unsafe.AsRef<STBTexteditStatePtr>(&Handle->Stb);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref ImGuiInputTextFlags Flags => ref Unsafe.AsRef<ImGuiInputTextFlags>(&Handle->Flags);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref uint ID => ref Unsafe.AsRef<uint>(&Handle->ID);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref int TextLen => ref Unsafe.AsRef<int>(&Handle->TextLen);
		/// <summary>
		/// To be documented.
		/// </summary>
		public byte* TextSrc { get => Handle->TextSrc; set => Handle->TextSrc = value; }
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref ImVector<byte> TextA => ref Unsafe.AsRef<ImVector<byte>>(&Handle->TextA);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref ImVector<byte> TextToRevertTo => ref Unsafe.AsRef<ImVector<byte>>(&Handle->TextToRevertTo);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref ImVector<byte> CallbackTextBackup => ref Unsafe.AsRef<ImVector<byte>>(&Handle->CallbackTextBackup);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref int BufCapacity => ref Unsafe.AsRef<int>(&Handle->BufCapacity);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref Vector2 Scroll => ref Unsafe.AsRef<Vector2>(&Handle->Scroll);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref float CursorAnim => ref Unsafe.AsRef<float>(&Handle->CursorAnim);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref bool CursorFollow => ref Unsafe.AsRef<bool>(&Handle->CursorFollow);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref bool SelectedAllMouseLock => ref Unsafe.AsRef<bool>(&Handle->SelectedAllMouseLock);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref bool Edited => ref Unsafe.AsRef<bool>(&Handle->Edited);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref bool WantReloadUserBuf => ref Unsafe.AsRef<bool>(&Handle->WantReloadUserBuf);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref int ReloadSelectionStart => ref Unsafe.AsRef<int>(&Handle->ReloadSelectionStart);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref int ReloadSelectionEnd => ref Unsafe.AsRef<int>(&Handle->ReloadSelectionEnd);
	}

}
